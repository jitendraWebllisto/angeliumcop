{"version":3,"sources":["ng://ngx-indexed-db/lib/ngx-indexed-db.ts","ng://ngx-indexed-db/utils/index.ts","ng://ngx-indexed-db/lib/ngx-indexed-db.service.ts","ng://ngx-indexed-db/lib/ngxindexeddb.module.ts"],"names":["indexedDB","window","mozIndexedDB","webkitIndexedDB","msIndexedDB","openDatabase","dbName","version","upgradeCallback","Promise","resolve","reject","db","request","open","onsuccess","event","result","onerror","error","onupgradeneeded","console","log","validateBeforeTransaction","storeName","objectStoreNames","contains","validateStoreName","createTransaction","options","trans","transaction","dbMode","oncomplete","complete","onabort","abort","optionsGenerator","type","e","NgxIndexedDBService","dbConfig","this","name","Error","storeSchemas","migrationFactory","objectStoresMeta","database","forEach","storeSchema","store","objectStore_1","createObjectStore","storeConfig","schema","createIndex","keypath","storeMigrations","Object","keys","map","k","parseInt","filter","v","oldVersion","sort","a","b","close","target","defineProperty","prototype","_currentStore","add","value","key","_this","then","DBMode","objectStore","evt","getByKey","get","getByID","id","getAll","_a","ResultAll","update","put","deleteRecord","delete","clear","openCursor","cursorCallback","keyRange","getByIndex","indexName","index","Injectable","Inject","args","CONFIG_TOKEN","InjectionToken","NgxIndexedDBModule","forRoot","ngModule","providers","provide","useValue","NgModule","declarations","imports","CommonModule"],"mappings":"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","sourcesContent":["export interface ObjectStoreMeta {\n\tstore: string;\n\tstoreConfig: { keyPath: string; autoIncrement: boolean; [key: string]: any };\n\tstoreSchema: ObjectStoreSchema[];\n}\n\nexport interface ObjectStoreSchema {\n\tname: string;\n\tkeypath: string | string[];\n\toptions: { unique: boolean; [key: string]: any };\n}\nexport type Key = string | number | Date | ArrayBufferView | ArrayBuffer | IDBArrayKey | IDBKeyRange;\nexport interface IndexDetails {\n\tindexName: string;\n\torder: string;\n}\nexport interface RequestEventTarget<T> extends EventTarget {\n\tresult: T | T[];\n}\n\nexport interface RequestEvent<T> extends Event {\n\ttarget: RequestEventTarget<T>;\n}\n\nconst indexedDB: IDBFactory =\n\twindow.indexedDB || (<any>window).mozIndexedDB || (<any>window).webkitIndexedDB || (<any>window).msIndexedDB;\n\nexport function openDatabase(dbName: string, version: number, upgradeCallback?: Function) {\n\treturn new Promise<IDBDatabase>((resolve, reject) => {\n\t\tconst request = indexedDB.open(dbName, version);\n\t\tlet db: IDBDatabase;\n\t\trequest.onsuccess = (event: Event) => {\n\t\t\tdb = request.result;\n\t\t\tresolve(db);\n\t\t};\n\t\trequest.onerror = (event: Event) => {\n\t\t\treject(`IndexedDB error: ${request.error}`);\n\t\t};\n\t\tif (typeof upgradeCallback === 'function') {\n\t\t\trequest.onupgradeneeded = (event: Event) => {\n\t\t\t\tconsole.log('checkout');\n\t\t\t\tupgradeCallback(event, db);\n\t\t\t};\n\t\t}\n\t});\n}\n\nexport function CreateObjectStore(\n\tdbName: string,\n\tversion: number,\n\tstoreSchemas: ObjectStoreMeta[],\n\tmigrationFactory?: () => { [key: number]: (db: IDBDatabase, transaction: IDBTransaction) => void }\n) {\n\tconst request: IDBOpenDBRequest = indexedDB.open(dbName, version);\n\n\trequest.onupgradeneeded = function(event: IDBVersionChangeEvent) {\n\t\tconst database: IDBDatabase = (event.target as any).result;\n\n\t\tstoreSchemas.forEach((storeSchema: ObjectStoreMeta) => {\n\t\t\tif (!database.objectStoreNames.contains(storeSchema.store)) {\n\t\t\t\tconst objectStore = database.createObjectStore(storeSchema.store, storeSchema.storeConfig);\n\t\t\t\tstoreSchema.storeSchema.forEach((schema: ObjectStoreSchema) => {\n\t\t\t\t\tobjectStore.createIndex(schema.name, schema.keypath, schema.options);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tconst storeMigrations = migrationFactory && migrationFactory();\n\t\tif (storeMigrations) {\n\t\t\tObject.keys(storeMigrations)\n\t\t\t\t.map(k => parseInt(k, 10))\n\t\t\t\t.filter(v => v > event.oldVersion)\n\t\t\t\t.sort((a, b) => a - b)\n\t\t\t\t.forEach(v => {\n\t\t\t\t\tstoreMigrations[v](database, request.transaction);\n\t\t\t\t});\n\t\t}\n\n\t\tdatabase.close();\n\t};\n\n\trequest.onsuccess = function(e: any) {\n\t\te.target.result.close();\n\t};\n}\n\nexport enum DBMode {\n\treadonly = 'readonly',\n\treadwrite = 'readwrite'\n}\n","export interface Options {\n\tstoreName: string;\n\tdbMode: IDBTransactionMode;\n\terror: (e: Event) => any;\n\tcomplete: (e: Event) => any;\n\tabort?: any;\n}\n\nexport function validateStoreName(db: IDBDatabase, storeName: string) {\n\treturn db.objectStoreNames.contains(storeName);\n}\n\nexport function validateBeforeTransaction(db: IDBDatabase, storeName: string, reject: Function) {\n\tif (!db) {\n\t\treject('You need to use the openDatabase function to create a database before you query it!');\n\t}\n\tif (!validateStoreName(db, storeName)) {\n\t\treject(`objectStore does not exists: ${storeName}`);\n\t}\n}\n\nexport function createTransaction(db: IDBDatabase, options: Options): IDBTransaction {\n\tlet trans: IDBTransaction = db.transaction(options.storeName, options.dbMode);\n\ttrans.onerror = options.error;\n\ttrans.oncomplete = options.complete;\n\ttrans.onabort = options.abort;\n\treturn trans;\n}\n\nexport function optionsGenerator(type: any, storeName: any, reject: Function, resolve: Function): Options {\n\treturn {\n\t\tstoreName: storeName,\n\t\tdbMode: type,\n\t\terror: (e: Event) => {\n\t\t\treject(e);\n\t\t},\n\t\tcomplete: (e: Event) => {\n\t\t\tresolve();\n\t\t},\n\t\tabort: (e: Event) => {\n\t\t\treject(e);\n\t\t}\n\t};\n}\n","import { Injectable, Inject } from '@angular/core';\nimport { CONFIG_TOKEN, DBConfig } from './ngxindexeddb.module';\nimport { openDatabase, DBMode, Key, RequestEvent, CreateObjectStore } from './ngx-indexed-db';\nimport { createTransaction, optionsGenerator, validateBeforeTransaction } from '../utils';\n\n@Injectable()\nexport class NgxIndexedDBService {\n\tset currentStore(_currentStore: string) {\n\t\tthis._currentStore = _currentStore;\n\t}\n\tprivate _currentStore: string;\n\n\tconstructor(@Inject(CONFIG_TOKEN) private dbConfig: DBConfig) {\n\t\tif (!dbConfig.name) {\n\t\t\tthrow new Error('NgxIndexedDB: Please, provide the dbName in the configuration');\n\t\t}\n\t\tif (!dbConfig.version) {\n\t\t\tthrow new Error('NgxIndexedDB: Please, provide the db version in the configuration');\n\t\t}\n\t\tCreateObjectStore(dbConfig.name, dbConfig.version, dbConfig.objectStoresMeta, dbConfig.migrationFactory);\n\t}\n\n\tadd<T>(value: T, key?: any) {\n\t\treturn new Promise<number>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then((db: IDBDatabase) => {\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readwrite, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\tlet request = objectStore.add(value, key);\n\t\t\t\trequest.onsuccess = (evt: any) => {\n\t\t\t\t\tkey = evt.target.result;\n\t\t\t\t\tresolve(key);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tgetByKey<T>(key: any) {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then((db: IDBDatabase) => {\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readonly, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\tlet request = objectStore.get(key);\n\t\t\t\trequest.onsuccess = function(event: Event) {\n\t\t\t\t\tresolve((<any>event.target).result);\n\t\t\t\t};\n\t\t\t\trequest.onerror = function(event: Event) {\n\t\t\t\t\treject(event);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tgetByID<T>(id: string | number) {\n\t\treturn new Promise<T>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then((db: IDBDatabase) => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readonly, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore),\n\t\t\t\t\trequest: IDBRequest;\n\t\t\t\trequest = objectStore.get(+id);\n\t\t\t\trequest.onsuccess = function(event: Event) {\n\t\t\t\t\tresolve((event.target as any).result as T);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tgetAll<T>() {\n\t\treturn new Promise<T[]>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readonly, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore),\n\t\t\t\t\tresult: Array<any> = [];\n\n\t\t\t\tconst request: IDBRequest = objectStore.getAll();\n\n\t\t\t\trequest.onerror = function(e) {\n\t\t\t\t\treject(e);\n\t\t\t\t};\n\t\t\t\trequest.onsuccess = function({ target: { result: ResultAll } }: RequestEvent<T>) {\n\t\t\t\t\tresolve(ResultAll as T[]);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tupdate<T>(value: T, key?: any) {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readwrite, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\ttransaction.oncomplete = event => {\n\t\t\t\t\tresolve(event);\n\t\t\t\t};\n\t\t\t\tobjectStore.put(value, key);\n\t\t\t});\n\t\t});\n\t}\n\n\tdeleteRecord(key: Key) {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readwrite, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\tlet request = objectStore.delete(key);\n\t\t\t\trequest.onsuccess = event => {\n\t\t\t\t\tresolve(event);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tclear() {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readwrite, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\tobjectStore.clear();\n\t\t\t\ttransaction.oncomplete = event => {\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tdelete(key: any) {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readwrite, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore);\n\t\t\t\tobjectStore['delete'](key);\n\t\t\t});\n\t\t});\n\t}\n\n\topenCursor(cursorCallback: (event: Event) => void, keyRange?: IDBKeyRange) {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readonly, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore),\n\t\t\t\t\trequest = objectStore.openCursor(keyRange);\n\n\t\t\t\trequest.onsuccess = (event: Event) => {\n\t\t\t\t\tcursorCallback(event);\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n\n\tgetByIndex(indexName: string, key: any) {\n\t\treturn new Promise<any>((resolve, reject) => {\n\t\t\topenDatabase(this.dbConfig.name, this.dbConfig.version).then(db => {\n\t\t\t\tvalidateBeforeTransaction(db, this._currentStore, reject);\n\t\t\t\tlet transaction = createTransaction(\n\t\t\t\t\t\tdb,\n\t\t\t\t\t\toptionsGenerator(DBMode.readonly, this._currentStore, reject, resolve)\n\t\t\t\t\t),\n\t\t\t\t\tobjectStore = transaction.objectStore(this._currentStore),\n\t\t\t\t\tindex = objectStore.index(indexName),\n\t\t\t\t\trequest = index.get(key);\n\t\t\t\trequest.onsuccess = (event: Event) => {\n\t\t\t\t\tresolve((<IDBOpenDBRequest>event.target).result);\n\t\t\t\t};\n\t\t\t});\n\t\t});\n\t}\n}\n","import { NgModule, ModuleWithProviders, InjectionToken } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NgxIndexedDBService } from './ngx-indexed-db.service';\nimport { CreateObjectStore } from './ngx-indexed-db';\n\nexport interface DBConfig {\n\tname: string;\n\tversion: number;\n\tobjectStoresMeta: ObjectStoreMeta[];\n\tmigrationFactory?: () => { [key: number]: (db: IDBDatabase, transaction: IDBTransaction) => void };\n}\n\nexport interface ObjectStoreMeta {\n\tstore: string;\n\tstoreConfig: { keyPath: string; autoIncrement: boolean; [key: string]: any };\n\tstoreSchema: ObjectStoreSchema[];\n}\n\nexport interface ObjectStoreSchema {\n\tname: string;\n\tkeypath: string;\n\toptions: { unique: boolean; [key: string]: any };\n}\n\nexport const CONFIG_TOKEN = new InjectionToken<DBConfig>(null);\n\n@NgModule({\n\tdeclarations: [],\n\timports: [CommonModule]\n})\nexport class NgxIndexedDBModule {\n\tstatic forRoot(dbConfig: DBConfig): ModuleWithProviders<NgxIndexedDBModule> {\n\t\treturn {\n\t\t\tngModule: NgxIndexedDBModule,\n\t\t\tproviders: [NgxIndexedDBService, { provide: CONFIG_TOKEN, useValue: dbConfig }]\n\t\t};\n\t}\n}\n"]}